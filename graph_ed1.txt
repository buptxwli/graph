#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <queue>
#include <cstdio>
using namespace std;
char in[100][100];
struct P
{
    int x;
    int y;
};
P point[100];
struct E
{
    int nextx;
    int nexty;
    int cost;
};
vector <E> edge[100];
bool mark[101];
int dis[101];
int main()
{

    for(int j=0;j<13;j++)      //建立图形
    {
        in[0][j]='#';
        in[1][j]='>';
        in[2][j]='>';
        in[3][j]='<';
        in[4][j]='<';
        in[5][j]='#';
    }
    for(int i=1;i<5;i++)
    {
        in[i][0]='X';
        in[i][4]='X';
        in[i][8]='X';
        in[i][12]='X';
    }
    int s=0;
    for(int i=0;i<6;i++)    //定义图上的坐标，s代表第几个点
    {
        for(int j=0;j<13;j++)
        {
            point[s].x=i;
            point[s].y=j;
            s++;
        }
    }
    for(int i=0;i<s;i++)
        edge[i].clear();
    for(int i=0;i<s;i++)
    {
        if(point[i].x==0)           //第一行只能往下
        {
            E tmp;
            tmp.cost=1;
            tmp.nextx=point[i].x+1;
            tmp.nexty=point[i].y;
            edge[i].push_back(tmp);

        }
        if(point[i].x==5)      //最后一行只能往上
        {
            E tmp;
            tmp.cost=1;
            tmp.nextx=point[i].x-1;
            tmp.nexty=point[i].y;
            edge[i].push_back(tmp);
        }
        if((point[i].x==1 || point[i].x==2) && point[i].y!=12)   //往右
        {
            if(point[i].x==1)
            {
                E tmp;
                tmp.cost=1;
                tmp.nextx=point[i].x;
                tmp.nexty=point[i].y+1;
                edge[i].push_back(tmp);
                tmp.nextx=point[i].x-1;
                tmp.nexty=point[i].y;
                edge[i].push_back(tmp);
            }
            else
            {
                E tmp;
                tmp.cost=1;
                tmp.nextx=point[i].x;
                tmp.nexty=point[i].y+1;
                edge[i].push_back(tmp);
            }
        }
        if((point[i].x==3 || point[i].x==4) && point[i].y!=0)    //往左
        {
            if(point[i].x==4)
            {
                E tmp;
                tmp.cost=1;
                tmp.nextx=point[i].x;
                tmp.nexty=point[i].y-1;
                edge[i].push_back(tmp);
                tmp.nextx=point[i].x+1;
                tmp.nexty=point[i].y;
                edge[i].push_back(tmp);
            }
            else
            {
                E tmp;
                tmp.cost=1;
                tmp.nextx=point[i].x;
                tmp.nexty=point[i].y-1;
                edge[i].push_back(tmp);
            }
        }
        if(in[point[i].x][point[i].y]=='X')     //交叉口再加个上下的临边
        {
            E tmp;
            tmp.cost=1;
            tmp.nextx=point[i].x+1;
            tmp.nexty=point[i].y;
            edge[i].push_back(tmp);
            tmp.nextx=point[i].x-1;
            edge[i].push_back(tmp);
        }
    }
    P start,last;
    scanf("%d%d%d%d",&start.x,&start.y,&last.x,&last.y);
    for(int i=0;i<s;i++)
    {
        dis[i]=-1;
        mark[i]=false;
    }
    dis[start.x*13+start.y]=0;
    mark[start.x*13+start.y]=true;
    P newp=start;
    for(int i=0;i<s;i++)
    {
        for(int j=0;j<edge[newp.x*13+newp.y].size();j++)
        {
            int m=edge[newp.x*13+newp.y][j].nextx;
            int n=edge[newp.x*13+newp.y][j].nexty;
            int c=edge[newp.x*13+newp.y][j].cost;
            if(mark[m*13+n]==true) continue;
            if(dis[m*13+n]==-1 || dis[m*13+n]>dis[newp.x*13+newp.y]+c)
                dis[m*13+n]=dis[newp.x*13+newp.y]+c;
        }
        int least=12121211;
        for(int j=0;j<s;j++)
        {
            if(mark[j]==true) continue;
            if(dis[j]==-1) continue;
            if(dis[j]<least)
            {
                least=dis[j];
                newp.x=j/13;
                newp.y=j%13;
            }
        }
        mark[newp.x*13+newp.y]=true;
    }
    printf("%d\n",dis[last.x*13+last.y]);
    return 0;
}
